# スライディングウィンドウアルゴリズム解説

## 問題の概要

バイナリ配列(0と1のみを含む配列)が与えられたとき、**連続する1の最大個数**を求める問題です。

### 例
- 入力: `[1, 1, 0, 1, 1, 1]`
- 出力: `3` (最後の3つの1が連続している)

---

## `findMaxConsecutiveOnesBySlidingWindow` のアルゴリズム

### 基本的な考え方

スライディングウィンドウ(可変長の区間)を使って、**連続する1の区間**を追跡します。

- `left`: ウィンドウの左端(開始位置)
- `right`: ウィンドウの右端(現在の位置)
- ウィンドウの長さ: `right - left + 1`

#### なぜ `+1` が必要なのか?

インデックスは0から始まるため、**要素の個数**を求めるには `+1` が必要です。

**具体例:**
```
配列: [1, 1, 1]
       ↑     ↑
     left  right
    (0)    (2)

right - left = 2 - 0 = 2  ← これでは2個になってしまう(間違い)
right - left + 1 = 2 - 0 + 1 = 3  ← 正しい個数
```

**一般的な考え方:**
- インデックス0からインデックス2までには、**3つ**の要素がある
- 範囲の長さ = 終点 - 始点 + 1

### アルゴリズムの流れ

```php
function findMaxConsecutiveOnesBySlidingWindow($nums)
{
    $result = 0;          // 最大の連続する1の個数
    $left = 0;            // ウィンドウの左端

    foreach($nums as $right => $num) {  // $rightがウィンドウの右端
        if ($num === 0) {
            // rightが指している位置の値が0だったら、次の位置(right + 1)から新しいウィンドウを開始
            $left = $right + 1;
        } else {
            // 1の場合、現在のウィンドウの長さを計算し、最大値を更新
            $result = max($result, $right - $left + 1);
        }
    }
    return $result;
}
```

---

## ステップバイステップの動作例

入力配列: `[1, 1, 0, 1, 1, 1]`

| ステップ | right | nums[right] | left | ウィンドウの長さ | result | 説明 |
|---------|-------|-------------|------|----------------|--------|------|
| 初期状態 | - | - | 0 | - | 0 | - |
| 1 | 0 | 1 | 0 | 0 - 0 + 1 = 1 | 1 | 1を発見、ウィンドウ長さ1 |
| 2 | 1 | 1 | 0 | 1 - 0 + 1 = 2 | 2 | 1を発見、ウィンドウ長さ2 |
| 3 | 2 | 0 | 3 | - | 2 | 0を発見、leftを3に移動 |
| 4 | 3 | 1 | 3 | 3 - 3 + 1 = 1 | 2 | 1を発見、ウィンドウ長さ1 |
| 5 | 4 | 1 | 3 | 4 - 3 + 1 = 2 | 2 | 1を発見、ウィンドウ長さ2 |
| 6 | 5 | 1 | 3 | 5 - 3 + 1 = 3 | **3** | 1を発見、ウィンドウ長さ3 |

**最終結果: 3**

---

## 視覚的な理解

```
配列: [1, 1, 0, 1, 1, 1]
インデックス: 0  1  2  3  4  5

ステップ2の状態:
      ↑  ↑
      L  R
     (0)(1)
→ ウィンドウ長さ = 1 - 0 + 1 = 2個
  (インデックス0と1の2つの要素)

ステップ3の状態:
配列: [1, 1, 0, 1, 1, 1]
               ↑
               L,R
              (2)
→ 0を発見、leftを3に移動

ステップ6の状態(最終):
配列: [1, 1, 0, 1, 1, 1]
               ↑     ↑
               L     R
              (3)   (5)
→ ウィンドウ長さ = 5 - 3 + 1 = 3個
  (インデックス3, 4, 5の3つの要素)
```

---

## アルゴリズムの特徴

### 長所
1. **時間計算量**: O(n) - 配列を1回だけ走査
2. **空間計算量**: O(1) - 固定数の変数のみ使用
3. **効率的**: 各要素を1回ずつ処理するだけ

### ポイント
- **rightが指している位置の値が0の場合**: ウィンドウをリセット(`left = right + 1`)
- **rightが指している位置の値が1の場合**: 現在のウィンドウ長さを計算し、最大値を更新

### 理解の鍵: ポインタの動き方

スライディングウィンドウの本質は、**2つのポインタの動き方の違い**にあります:

- **`right`ポインタ**: 毎回必ず1つずつ右に移動(foreachで自動的に進む)
- **`left`ポインタ**: 0に遭遇するまでは位置を固定、0を見つけたら一気にジャンプ

```
ループ1回目:  [1, 1, 0, 1, 1, 1]
               ↑
              L,R  ← 両方スタート位置

ループ2回目:  [1, 1, 0, 1, 1, 1]
               ↑  ↑
               L  R  ← rightだけ進む(leftは固定)

ループ3回目:  [1, 1, 0, 1, 1, 1]
               ↑     ↑
               L     R  ← rightだけ進む(0を発見!)
                         leftは次ループで移動

ループ4回目:  [1, 1, 0, 1, 1, 1]
                      ↑
                     L,R  ← leftがジャンプ(right + 1へ)

ループ5回目:  [1, 1, 0, 1, 1, 1]
                      ↑  ↑
                      L  R  ← またrightだけ進む

ループ6回目:  [1, 1, 0, 1, 1, 1]
                      ↑     ↑
                      L     R  ← rightだけ進む
```

この「**rightは常に前進、leftは必要な時だけジャンプ**」という動きをイメージすることで、アルゴリズムの理解が深まります。

---

## 通常のカウント方式との比較

### 通常のカウント方式 (`findMaxConsecutiveOnes`)
```php
function findMaxConsecutiveOnes($nums)
{
    $result = 0;
    $count = 0;

    foreach ($nums as $num) {
        if ($num === 1) {
            $count += 1;
        } else {
            $count = 0;  // 値が0だったらカウントをリセット
        }
        $result = max($result, $count);
    }
    return $result;
}
```

**違い:**
- カウント方式: 連続する1の個数を直接カウント
- スライディングウィンドウ: 区間(left〜right)の長さを計算

両方とも時間計算量はO(n)ですが、スライディングウィンドウの考え方は、より複雑な問題(例: K個まで0を許容する場合)に拡張しやすいという利点があります。

---

## まとめ

スライディングウィンドウアルゴリズムは:
- **可変長の区間**を効率的に管理する手法
- 左端(`left`)と右端(`right`)を適切に調整することで、条件を満たす区間を追跡
- 配列やリストの**連続する部分列**に関する問題に有効

このアプローチは、最大/最小の連続部分列、特定条件を満たす部分列などの問題に応用できます。

---

## Appendix: スライディングウィンドウとツーポインタアルゴリズムの関係

### 包含関係

**スライディングウィンドウは、ツーポインタアルゴリズムの特殊な形**です。

```
┌─────────────────────────────────────┐
│  ツーポインタアルゴリズム           │
│  (2つのポインタで効率的に処理)      │
│                                      │
│  ┌────────────────────────┐         │
│  │ スライディングウィンドウ│         │
│  │ (連続区間を2つのポインタ│         │
│  │  で管理する特殊ケース)  │         │
│  └────────────────────────┘         │
│                                      │
│  その他のパターン:                  │
│  - 対向型(両端から中央へ)           │
│  - 追跡型(片方が先行)               │
└─────────────────────────────────────┘
```

### ツーポインタアルゴリズムの主なパターン

#### 1. 対向型 (Opposite Direction)
両端から中央に向かって進む

```
用途: 二数の和、回文判定など

[1, 2, 3, 4, 5]
 ↑           ↑
 L           R

 ↓  両方とも中央へ  ↓

[1, 2, 3, 4, 5]
    ↑     ↑
    L     R
```

**例: Two Sum (ソート済み配列)**
```php
function twoSum($nums, $target) {
    $left = 0;
    $right = count($nums) - 1;

    while ($left < $right) {
        $sum = $nums[$left] + $nums[$right];
        if ($sum === $target) {
            return [$left, $right];
        } elseif ($sum < $target) {
            $left++;
        } else {
            $right--;
        }
    }
}
```

#### 2. 追跡型 (Fast-Slow Pointers)
片方が先に進み、もう片方が追いかける

```
用途: 重複削除、サイクル検出など

[1, 1, 2, 3, 3]
 ↑  ↑
 S  F  ← Fast が先行、Slow が追跡
```

**例: 重複を削除して配列を詰める**
```php
function removeDuplicates(&$nums) {
    $slow = 0;

    for ($fast = 1; $fast < count($nums); $fast++) {
        if ($nums[$fast] !== $nums[$slow]) {
            $slow++;
            $nums[$slow] = $nums[$fast];
        }
    }
    return $slow + 1;
}
```

#### 3. スライディングウィンドウ型 (今回の例)
連続する区間(ウィンドウ)を管理

```
用途: 最大/最小の連続部分列、部分文字列問題など

[1, 1, 0, 1, 1, 1]
 ↑     ↑
 L     R  ← 区間 [L, R] を維持
```

### 今回のコードで見る両方の性質

```php
function findMaxConsecutiveOnesBySlidingWindow($nums) {
    $left = 0;                           // ← ポインタ1
    foreach($nums as $right => $num) {   // ← ポインタ2
        // $left と $right で「連続する1の区間」を管理
        // ✓ ツーポインタアルゴリズム
        // ✓ スライディングウィンドウアルゴリズム
    }
}
```

### まとめ

- **すべてのスライディングウィンドウ** → ツーポインタアルゴリズム ✓
- **すべてのツーポインタ** → スライディングウィンドウ ✗

スライディングウィンドウの特徴は:
- 必ず**連続した部分配列**を扱う
- `left`と`right`で**区間の範囲**を表現する
- 区間の長さや内容に着目する

一方、ツーポインタアルゴリズムはより広い概念で、2つのポインタを使う様々な手法を含みます。
