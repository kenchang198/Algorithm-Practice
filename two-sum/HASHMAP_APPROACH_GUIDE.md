# Two Sum 問題：ハッシュマップアプローチの発想法

## 問題の概要

Two Sum 問題を解く際、ハッシュマップを使った効率的な解法を理解するためのガイドです。

## よくある間違い：事前に全てを準備するアプローチ

### 問題のある実装例

```php
function twoSum(array $nums, int $target): array
{
    $map = [];
    // 最初に全ての要素をハッシュマップに追加
    foreach ($nums as $idx => $num) {
        $map[$num] = $idx;
    }
    // その後、各要素について target - num をチェック
    foreach ($nums as $idx => $num) {
        if (isset($map[$target - $num])) {
            return [$map[$target - $num], $idx];
        }
    }
    return [];
}
```

### この方法の問題点

1. **2 つのループが必要**：効率が悪い（時間計算量は O(n)だが、実装が冗長）
2. **同じインデックスを使う可能性**：例えば `[3, 3]` で `target = 6` の場合、最初のループで `$map[3] = 1` となり、2 番目のループで同じインデックスを参照してしまう可能性がある
3. **無駄なメモリ使用**：全ての要素を事前に保存する必要がない

## 正しいアプローチ：1 パスで解く方法

### 効率的な実装例

```php
function twoSumBetter($target, $nums) {
    $map = [];
    foreach ($nums as $i => $num) {
        $need = $target - $num;
        if (isset($map[$need])) {
            return [$map[$need], $i];
        }
        $map[$num] = $i;
    }
}
```

### この方法の利点

1. **1 つのループで完結**：シンプルで効率的
2. **同じインデックスを使わない**：チェックしてから追加するため、同じインデックスを 2 回使うことがない
3. **必要な分だけハッシュマップを構築**：メモリ効率が良い

## 発想のコツ

### 1. 「必要な情報を後から見つける」ではなく「今見た情報を後で使う」と考える

**間違った発想**：

- 「全ての値を事前にマップに入れて、後で検索できるようにしよう」

**正しい発想**：

- 「今見た値は、後で来る値の相方になる可能性がある。だから今の値を保存しておこう」
- 「過去に見た値のうち、今の値とペアになるものがあるか確認しよう」

### 2. 「過去の情報を活用する」視点

各ステップで考えること：

- **過去に見た値のうち、今の値とペアになるものがあるか？**
- **なければ、今の値は将来の値の相方候補として保存**

### 3. アルゴリズムのパターンとして覚える

**「1 パスで解く」パターン**：

- 配列を 1 回だけ走査しながら、必要な情報を蓄積
- その場で判定・処理を行う
- 例：Contains Duplicate 問題も同様のパターン

### 4. 具体例でトレースする

```text
nums = [2, 1, 5, 8], target = 3

i=0, num=2:
  - need = 3 - 2 = 1
  - $mapに1はあるか？ → ない
  - $map[2] = 0 を保存（将来、1が来た時に使える）
  - $map = {2: 0}

i=1, num=1:
  - need = 3 - 1 = 2
  - $mapに2はあるか？ → ある！($map[2] = 0)
  - ペアが見つかった！ → [0, 1] を返す
```

## 練習のアドバイス

### 1. 事前に全てを準備する必要はないと意識する

- 「全てを準備してから処理」という発想を捨てる
- 「必要な時に必要な分だけ準備」という発想に切り替える

### 2. 「今見ている要素と、過去に見た要素の関係」を考える

- 現在の要素：`num`
- 必要な相方：`target - num`
- 過去に見た要素の中に相方がいるか？

### 3. 1 パスで解けるか検討する

- 複数のループが必要な場合、1 つのループにまとめられないか考える
- 走査しながら情報を蓄積し、その場で判定できないか？

### 4. 同じインデックスを使わないようにする

- **チェックしてから追加**の順序を守る
- これにより、同じインデックスを 2 回使うことを防げる

## 他の問題への応用

この発想は以下のような問題でも使えます：

- **Contains Duplicate**：過去に見た値の中に、今の値と同じものがあるか？
- **Group Anagrams**：過去に見たアナグラムの中に、今の文字列のアナグラムがあるか？
- **Longest Substring Without Repeating Characters**：過去に見た文字の中に、今の文字と同じものがあるか？

## まとめ

**重要なポイント**：

1. ✅ 1 パスで解く（1 つのループで完結）
2. ✅ チェックしてから追加（同じインデックスを使わない）
3. ✅ 「今見た情報を後で使う」という発想
4. ✅ 事前に全てを準備する必要はない

この発想を身につけることで、ハッシュマップを使った問題を効率的に解けるようになります。
