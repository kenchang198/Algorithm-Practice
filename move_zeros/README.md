# Move Zeros アルゴリズム解説

## 問題概要

配列内のすべての 0 を配列の末尾に移動し、非ゼロ要素の相対的な順序を維持する問題です。

**例:**

- 入力: `[0, 1, 0, 3, 12]`
- 出力: `[1, 3, 12, 0, 0]`

**制約:**

- 元の配列を in-place で変更する必要がある
- 非ゼロ要素の順序は維持する必要がある
- 最小限の操作回数で実装する

**LeetCode 問題**: [283. Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)

---

## 解法 1: 2 パスアプローチ（Two-Pass Approach）

### アルゴリズムの流れ

1. **第 1 パス**: 非ゼロ要素を左から順に詰めていく
2. **第 2 パス**: 残りの位置を 0 で埋める

### 実装例

```python
def move_zeros(nums):
    left = 0

    # 第1パス: 非ゼロ要素を左に詰める
    for num in nums:
        if num != 0:
            nums[left] = num
            left += 1

    # 第2パス: 残りを0で埋める
    for i in range(left, len(nums)):
        nums[i] = 0

    return nums
```

### 時間計算量

- **時間計算量**: O(n) - 配列を 2 回走査する
- **空間計算量**: O(1) - 追加のメモリを使用しない

### ステップバイステップの実行例

入力: `[0, 1, 0, 3, 12]`

```
初期状態: [0, 1, 0, 3, 12], left = 0
          ↑
        left

第1パス（非ゼロ要素を左に詰める）:
- num = 0: スキップ（left = 0のまま）
- num = 1: nums[0] = 1, left = 1 → [1, 1, 0, 3, 12]
            ↑
          left
- num = 0: スキップ（left = 1のまま）
- num = 3: nums[1] = 3, left = 2 → [1, 3, 0, 3, 12]
                 ↑
               left
- num = 12: nums[2] = 12, left = 3 → [1, 3, 12, 3, 12]
                      ↑
                    left

第2パス（残りを0で埋める）:
- i = 3: nums[3] = 0 → [1, 3, 12, 0, 12]
- i = 4: nums[4] = 0 → [1, 3, 12, 0, 0]

最終結果: [1, 3, 12, 0, 0]
```

### 操作回数の分析

入力: `[0, 1, 0, 3, 12]` (非ゼロ要素: 3 個、ゼロ要素: 2 個)

- **第 1 パス**: 非ゼロ要素の書き込み = 3 回
- **第 2 パス**: ゼロ要素の書き込み = 2 回
- **合計**: 5 回の書き込み操作

---

## 解法 2: 1 パスアプローチ（One-Pass Approach / Two Pointers）

### アルゴリズムの流れ

2 つのポインタ（`left`と`right`）を使用して、1 パスで処理します。

- `left`: 次に非ゼロ要素を配置する位置を指す
- `right`: 現在処理中の要素を指す

`right`が非ゼロ要素を見つけたら、`left`と`right`の要素をスワップし、`left`を進めます。

### 実装例

```python
def move_zeros(nums):
    left = 0

    for right in range(len(nums)):
        if nums[right] != 0:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1

    return nums
```

### 時間計算量

- **時間計算量**: O(n) - 配列を 1 回だけ走査する
- **空間計算量**: O(1) - 追加のメモリを使用しない

### ステップバイステップの実行例

入力: `[0, 1, 0, 3, 12]`

```
初期状態: [0, 1, 0, 3, 12]
          ↑  ↑
        left right

right = 0: nums[0] = 0 → スキップ
          ↑
        left, right

right = 1: nums[1] = 1 ≠ 0 → スワップ → [1, 0, 0, 3, 12]
             ↑  ↑
           left right
           left = 1

right = 2: nums[2] = 0 → スキップ
                ↑  ↑
              left right

right = 3: nums[3] = 3 ≠ 0 → スワップ → [1, 3, 0, 0, 12]
                   ↑  ↑
                 left right
                 left = 2

right = 4: nums[4] = 12 ≠ 0 → スワップ → [1, 3, 12, 0, 0]
                      ↑  ↑
                    left right
                    left = 3

最終結果: [1, 3, 12, 0, 0]
```

### 操作回数の分析

入力: `[0, 1, 0, 3, 12]` (非ゼロ要素: 3 個)

- **スワップ操作**: 3 回（非ゼロ要素の数だけ）
- **各スワップ**: 2 回の書き込み（left と right の要素を交換）
- **合計書き込み**: 6 回（ただし、配列の走査は 1 回のみ）

**注意**: スワップは 2 つの要素を書き換えるため、書き込み回数は 2 パスアプローチより多くなる場合があります。しかし、配列の走査回数が 1 回で済むため、キャッシュ効率が良く、実際のパフォーマンスは優れています。

---

## 解法の比較

| 項目           | 2 パスアプローチ              | 1 パスアプローチ（基本）    | 1 パスアプローチ（最適化）  |
| -------------- | ----------------------------- | --------------------------- | --------------------------- |
| 時間計算量     | O(n)                          | O(n)                        | O(n)                        |
| 空間計算量     | O(1)                          | O(1)                        | O(1)                        |
| 配列の走査回数 | 2 回                          | 1 回                        | 1 回                        |
| 書き込み操作   | n 回（非ゼロ要素数 + ゼロ数） | 2× 非ゼロ要素数（スワップ） | 2× 移動が必要な非ゼロ要素数 |
| スワップ操作   | なし                          | 非ゼロ要素数だけ            | 移動が必要な要素だけ        |
| キャッシュ効率 | やや劣る（2 回走査）          | 良好                        | 良好                        |

### どちらが優れているか？

**1 パスアプローチ（最適化版）が最も優れています**。理由：

1. **効率性**: 配列を 1 回だけ走査するため、キャッシュ効率が良い
2. **書き込み回数の削減**: 既に正しい位置にある要素のスワップを避ける
3. **コードの簡潔性**: よりシンプルで理解しやすい
4. **実用的なパフォーマンス**: 大規模な配列で優位性が顕著

### パフォーマンス比較の具体例

入力: `[1, 2, 3, 0, 0]` (すべての非ゼロ要素が既に正しい位置)

- **2 パスアプローチ**:

  - 第 1 パス: 3 回の書き込み（1, 2, 3 を再配置）
  - 第 2 パス: 2 回の書き込み（0 で埋める）
  - **合計**: 5 回の書き込み

- **1 パスアプローチ（基本）**:

  - 3 回のスワップ = 6 回の書き込み（不要なスワップを含む）

- **1 パスアプローチ（最適化）**:
  - 0 回のスワップ（すべての要素が既に正しい位置）
  - **合計**: 0 回の書き込み（走査のみ）

この例から、最適化版が特に優れていることがわかります。

---

## 最適化された実装

### Python 版（推奨）

```python
def move_zeros(nums):
    """
    配列内のすべての0を末尾に移動する

    Args:
        nums: 整数のリスト（in-placeで変更される）

    Returns:
        None（配列はin-placeで変更される）
    """
    left = 0

    for right in range(len(nums)):
        if nums[right] != 0:
            if left != right:  # 最適化: 同じ位置の場合はスワップ不要
                nums[left], nums[right] = nums[right], nums[left]
            left += 1
```

### PHP 版（推奨）

```php
<?php
/**
 * 配列内のすべての0を末尾に移動する
 *
 * @param array $nums 整数の配列（参照渡しで変更される）
 * @return array 変更後の配列
 */
function move_zeros(array &$nums): array {
    $left = 0;

    for ($right = 0; $right < count($nums); $right++) {
        if ($nums[$right] !== 0) {
            if ($left !== $right) {  // 最適化: 同じ位置の場合はスワップ不要
                [$nums[$left], $nums[$right]] = [$nums[$right], $nums[$left]];
            }
            $left++;
        }
    }

    return $nums;
}
```

### 最適化のポイント

`if (left != right)` のチェックを追加することで、同じ位置での不要なスワップを避けます。これにより、既に正しい位置にある要素の書き込みを削減できます。

---

## 言語別の実装の違い（PHP vs Python）

### PHP で参照渡しが必要な理由

この問題では、**配列を in-place で変更する**必要があります。PHP と Python では、この要件を満たすための実装方法が異なります。

#### Python の場合

Python では、リスト（配列）は**参照型**として扱われます。そのため、関数に渡したリストを関数内で変更すると、元のリストも自動的に変更されます。

```python
def move_zeros(nums):
    nums[0] = 1  # 元のリストが変更される

nums = [0, 1, 2]
move_zeros(nums)
print(nums)  # [1, 1, 2] - 元のリストが変更されている
```

#### PHP の場合

PHP では、配列は**値渡し**として扱われます。そのため、関数内で配列を変更しても、元の配列には影響しません。**参照渡し（`&`）**を使用することで、元の配列を直接変更できます。

```php
// ❌ 値渡し - 元の配列は変更されない
function move_zeros(array $nums): array {
    $nums[0] = 1;  // コピーが変更されるだけ
    return $nums;  // 新しい配列を返す必要がある
}

$nums = [0, 1, 2];
move_zeros($nums);
// $nums は [0, 1, 2] のまま（変更されていない）

// ✅ 参照渡し - 元の配列が変更される（in-place）
function move_zeros(array &$nums): array {
    $nums[0] = 1;  // 元の配列が変更される
    return $nums;
}

$nums = [0, 1, 2];
move_zeros($nums);
// $nums は [1, 1, 2] に変更されている
```

### なぜ参照渡しが必要か？

1. **問題の要件**: LeetCode などの問題では、**in-place で変更する**ことが求められます。これは、新しい配列を作成せず、元の配列を直接変更することを意味します。

2. **メモリ効率**: 参照渡しを使用することで、配列のコピーを作成せずに済み、メモリ使用量を削減できます。

3. **パフォーマンス**: 大規模な配列では、コピーを作成するオーバーヘッドを避けることで、パフォーマンスが向上します。

### 実装例の比較

```php
// 値渡しの場合（問題の要件を満たさない）
function move_zeros_by_value(array $nums): array {
    // ... 処理 ...
    return $nums;  // 新しい配列を返す必要がある
}

// 参照渡しの場合（問題の要件を満たす）
function move_zeros_by_reference(array &$nums): array {
    // ... 処理 ...
    return $nums;  // 同じ配列への参照を返す
}
```

**結論**: PHP で in-place 変更を実現するには、参照渡し（`&$nums`）が必須です。これにより、問題の解答要件を満たし、メモリ効率とパフォーマンスの両方を最適化できます。

---

## 配列分割代入（Array Destructuring）によるスワップ操作

### 配列分割代入とは？

PHP 7.1 で導入された**配列分割代入（Array Destructuring）**機能により、配列の要素を直接変数に代入できるようになりました。この機能を利用することで、一時変数を使わずに変数の値を交換（スワップ）することが可能です。

```php
// 基本的な配列分割代入
[$a, $b] = [1, 2];
echo $a; // 1
echo $b; // 2

// スワップ操作（一時変数不要）
$a = 5;
$b = 10;
[$a, $b] = [$b, $a];
echo $a; // 10
echo $b; // 5
```

### なぜスワップ操作が可能なのか？

`[$nums[$left], $nums[$right]] = [$nums[$right], $nums[$left]];` という構文が動作する理由は、**右辺が先に評価される**ためです。

#### 実行の流れ

1. **右辺の評価**: `[$nums[$right], $nums[$left]]` が先に評価され、一時的な配列が作成されます

   - 例: `$nums[$right] = 1`, `$nums[$left] = 0` の場合、`[1, 0]` という配列が作成される

2. **左辺への代入**: 作成された配列の要素が、左辺の変数に順番に代入されます

   - `$nums[$left] = 1`（配列の最初の要素）
   - `$nums[$right] = 0`（配列の 2 番目の要素）

3. **結果**: 値が交換される

#### ステップバイステップの例

```php
$nums = [0, 1, 0, 3, 12];
$left = 0;
$right = 1;

// スワップ前
echo "スワップ前: nums[$left] = {$nums[$left]}, nums[$right] = {$nums[$right]}\n";
// 出力: スワップ前: nums[0] = 0, nums[1] = 1

// スワップ操作
[$nums[$left], $nums[$right]] = [$nums[$right], $nums[$left]];

// スワップ後
echo "スワップ後: nums[$left] = {$nums[$left]}, nums[$right] = {$nums[$right]}\n";
// 出力: スワップ後: nums[0] = 1, nums[1] = 0
```

### 従来の方法との比較

#### 従来の方法（一時変数を使用）

```php
// 一時変数を使ったスワップ
$temp = $nums[$left];
$nums[$left] = $nums[$right];
$nums[$right] = $temp;
```

**デメリット**:

- 一時変数が必要（メモリ使用量が増える）
- コードが 3 行必要
- 一時変数の名前を考える必要がある

#### 配列分割代入を使用

```php
// 配列分割代入を使ったスワップ
[$nums[$left], $nums[$right]] = [$nums[$right], $nums[$left]];
```

**メリット**:

- 一時変数が不要（メモリ効率が良い）
- 1 行で完結（コードが簡潔）
- 可読性が向上
- 意図が明確（「値を交換する」という操作が明確）

### PHP 7.1 以降の機能

配列分割代入は **PHP 7.1** で導入されました。PHP 7.0 以前では、`list()` 関数を使用する必要がありました。

```php
// PHP 7.0 以前（list()関数を使用）
list($a, $b) = [1, 2];

// PHP 7.1 以降（短縮構文[]を使用）推奨
[$a, $b] = [1, 2];
```

**注意**: `list()` 関数は PHP 7.1 以降では非推奨ではありませんが、短縮構文 `[]` の使用が推奨されています。

### その他の使用例

配列分割代入は、スワップ操作以外にも様々な場面で活用できます。

#### 1. 複数の変数への代入

```php
$data = ['John', 'Doe', 30];
[$firstName, $lastName, $age] = $data;
```

#### 2. 関数の戻り値の分割代入

```php
function getUserInfo() {
    return ['John', 'john@example.com', 30];
}

[$name, $email, $age] = getUserInfo();
```

#### 3. 連想配列の分割代入（PHP 7.1+）

```php
$user = ['name' => 'John', 'email' => 'john@example.com'];
['name' => $name, 'email' => $email] = $user;
```

#### 4. 配列の一部だけを取得

```php
$data = [1, 2, 3, 4, 5];
[$first, , $third] = $data;  // 2番目の要素をスキップ
// $first = 1, $third = 3
```

### 参考文献

- **PHP 公式マニュアル**: 配列の分割代入（Array Destructuring）
  - [配列の型](https://www.php.net/manual/ja/language.types.array.php) - 配列分割代入の基本的な説明
  - [list()関数](https://www.php.net/manual/ja/function.list.php) - `list()`関数の説明（PHP 7.1 以降は短縮構文`[]`が推奨）
- **PHP 7.1 の新機能**: [PHP 7.1 の新機能と変更点](https://www.php.net/manual/ja/migration71.new-features.php) - 配列分割代入の導入について

### スワップ操作の理解のコツ

`left`が移動するたびに 0 の位置を指す動きを理解するためのポイント：

#### 1. left の役割を理解する

`left`は「**次に非ゼロ要素を配置する位置**」を指します。この位置には通常、**0 が入っています**（または 0 になる予定です）。

#### 2. なぜ left の位置に 0 があるのか？

- **最初**: `left=0`で、配列の先頭を指します
- **先頭が 0 の場合**: そのまま 0 が残り、`left`は進みません
- **先頭が非ゼロの場合**: スワップ後、`left`は進みます
- **重要な不変条件**: `left`より前の位置はすべて非ゼロ要素です
- **結果**: `left`の位置には常に 0（または非ゼロ要素を配置する余地）があります

#### 3. スワップの動きをイメージする

```
[rightが発見した非ゼロ要素] ← rightが指す位置
[0] ← leftが指す位置
        ↓ スワップ
[非ゼロ要素] ← leftの位置に移動
[0] ← rightの位置に移動
```

#### 4. 視覚的なイメージ

```
[非ゼロ, 非ゼロ, ..., 非ゼロ, 0, 0, ..., 0, ?, ?, ...]
                 ↑                    ↑
               left                 right
```

- **left より前**: すべて非ゼロ要素（確定）
- **left の位置**: 0（次に非ゼロ要素を配置する位置）
- **left から right まで**: 処理済みの 0 が含まれる可能性
- **right 以降**: まだチェックしていない

#### 5. 実行例で理解する

入力: `[0, 1, 0, 3, 12]`

```
初期: [0, 1, 0, 3, 12]
      ↑
    left=0 (0が入っている)

right=1: 1を発見！
  [0, 1, 0, 3, 12]
   ↑  ↑
 left right
 スワップ: nums[0]とnums[1]を交換
  [1, 0, 0, 3, 12]
      ↑
    left=1 (0が入っている位置に更新)

right=3: 3を発見！
  [1, 0, 0, 3, 12]
      ↑     ↑
    left  right
 スワップ: nums[1]とnums[3]を交換
  [1, 3, 0, 0, 12]
         ↑
       left=2 (0が入っている位置に更新)
```

#### 6. 理解のポイントまとめ

1. **left は「非ゼロ要素を配置する位置」を指す**

   - この位置には通常 0 が入っている
   - 非ゼロ要素を見つけたら、この位置に移動させる

2. **スワップのイメージ**

   - 「right が発見した非ゼロ要素」と「left が指す 0」を交換する
   - 交換後、left の位置には非ゼロ要素が入る

3. **left が進むタイミング**

   - 非ゼロ要素を配置した後、left を 1 つ進める
   - これにより、left は常に「次に非ゼロ要素を配置する位置」を指す

4. **不変条件（Invariant）**
   - left より前の要素はすべて非ゼロ
   - left の位置には 0 が入っている（または非ゼロ要素を配置する余地がある）
   - left から right までの間には、処理済みの 0 が含まれる可能性がある

**より詳細な視覚化デモ**: `swap_visualization.php` を実行すると、ステップバイステップで動作を確認できます。

---

## 実装の詳細解説

### Two Pointers パターン

この問題は典型的な **Two Pointers** パターンの問題です。

- **Slow Pointer (`left`)**: 非ゼロ要素を配置する位置を追跡
- **Fast Pointer (`right`)**: 配列全体を走査

### アルゴリズムの動作原理

#### 1 パスアプローチの動作イメージ

```
初期: [0, 1, 0, 3, 12]
      ↑  ↑
    left right

ステップ1: right=0, 値=0 → スキップ
      ↑  ↑
    left right

ステップ2: right=1, 値=1 → スワップ
      [1, 0, 0, 3, 12]
         ↑  ↑
       left right

ステップ3: right=2, 値=0 → スキップ
         ↑     ↑
       left   right

ステップ4: right=3, 値=3 → スワップ
      [1, 3, 0, 0, 12]
            ↑  ↑
          left right

ステップ5: right=4, 値=12 → スワップ
      [1, 3, 12, 0, 0]
               ↑  ↑
             left right
```

### なぜこのアルゴリズムが機能するのか？

1. **不変条件（Invariant）**:

   - `left`より前の要素はすべて非ゼロ
   - `left`から`right`までの要素には、処理済みのゼロが含まれる可能性がある

2. **動作の流れ**:

   - `right`が非ゼロ要素を見つけると、それを`left`の位置に移動
   - `left`は常に「次に非ゼロ要素を配置する位置」を指している
   - `right`がゼロを見つけると、`left`は進まず、ゼロは後ろに残る
   - 最終的に、`left`より前はすべて非ゼロ要素、`left`以降はすべてゼロになる

3. **数学的な証明**:
   - ループ終了時、`right = n`（配列の長さ）
   - `left`より前の要素はすべて非ゼロ（非ゼロ要素のみが`left`の位置に配置される）
   - `left`以降の要素はすべてゼロ（非ゼロ要素はすべて`left`より前に移動済み）

---

## テストケースとエッジケース

### 基本的なテストケース

```python
# テストケース1: 基本的なケース
assert move_zeros([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]

# テストケース2: すべてゼロ
assert move_zeros([0, 0, 0]) == [0, 0, 0]

# テストケース3: ゼロなし
assert move_zeros([1, 2, 3]) == [1, 2, 3]

# テストケース4: 先頭がゼロ
assert move_zeros([0, 0, 1]) == [1, 0, 0]

# テストケース5: 末尾がゼロ
assert move_zeros([1, 2, 0]) == [1, 2, 0]

# テストケース6: 単一要素
assert move_zeros([0]) == [0]
assert move_zeros([1]) == [1]
```

### エッジケースの詳細解説

#### 1. すべてゼロの場合

```
入力: [0, 0, 0]
処理: すべての要素がゼロのため、スワップは発生しない
出力: [0, 0, 0]
```

- `left`は 0 のまま進まない
- 配列は変更されない

#### 2. ゼロがない場合

```
入力: [1, 2, 3]
処理: すべての要素が非ゼロのため、left == right の状態が続く
出力: [1, 2, 3]（最適化版ではスワップなし）
```

- 最適化版では、不要なスワップを避けられる

#### 3. 先頭がゼロの場合

```
入力: [0, 0, 1]
処理: 最初の2つのゼロをスキップし、最後の1を先頭に移動
出力: [1, 0, 0]
```

- 非ゼロ要素が少ない場合の典型的なケース

#### 4. 末尾がゼロの場合

```
入力: [1, 2, 0]
処理: 1と2は既に正しい位置、0は末尾に残る
出力: [1, 2, 0]
```

- 最適化版では、1 と 2 のスワップは発生しない

---

## 関連する問題

- [Remove Element](https://leetcode.com/problems/remove-element/)
- [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- [Partition Array According to Given Pivot](https://leetcode.com/problems/partition-array-according-to-given-pivot/)

これらはすべて **Two Pointers** パターンを使用する類似問題です。

---

## 実装ファイルの構成

このプロジェクトには以下の実装ファイルが含まれています：

### Python 実装

- `move_zeros.py`: 2 パスアプローチ
- `move_zeros_swap.py`: 1 パスアプローチ（基本版）
- `move_zeros_optimized.py`: 1 パスアプローチ（最適化版）**推奨**

### PHP 実装

- `move_zeros.php`: 2 パスアプローチ
- `move_zeros_swap.php`: 1 パスアプローチ（基本版）
- `move_zeros_optimized.php`: 1 パスアプローチ（最適化版）**推奨**

### デバッグ用ファイル

- `trace.php`: 2 パスアプローチのトレース版
- `reference_demo.php`: 参照渡し vs 値渡しのデモンストレーション
- `array_destructuring_demo.php`: 配列分割代入（Array Destructuring）の詳細な解説とデモンストレーション
- `swap_visualization.php`: スワップ操作の視覚化デモ（left ポインタの動きを理解するための詳細なトレース）

## 推奨実装

**本番環境では、最適化版（`move_zeros_optimized.py` または `move_zeros_optimized.php`）を使用することを強く推奨します。**

理由：

1. 配列を 1 回だけ走査するため、キャッシュ効率が良い
2. 不要なスワップを避けるため、書き込み回数が最小限
3. コードが簡潔で理解しやすい
4. エッジケース（すべて非ゼロ要素など）で特に優位性が発揮される

## 参考リンク

- [LeetCode 283: Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)
